[{"id":0,"href":"/calculations/","title":"Calculations","parent":"Learning Julia","content":""},{"id":1,"href":"/scripting/","title":"Scripting","parent":"Learning Julia","content":""},{"id":2,"href":"/calculations/arithmetic/","title":"Arithmetic","parent":"Calculations","content":" Using Julia as a Calculator Julia supports all of the arithmetic operators you would expect to find on a calculator:\naddition: + subtraction: - multiplication: * division: / exponentiation: ^ Go ahead and try using these operators in the REPL. The result of these calculations is displayed on the next line.\njulia\u0026gt; 2 + 2 4 julia\u0026gt; 5 - 3 2 julia\u0026gt; 5 * 6 30 julia\u0026gt; 5 / 2 2.5 julia\u0026gt; 5 ^ 2 25 You can use parentheses to change the order of evaluation:\njulia\u0026gt; (2 + 6) * 3 / 4 6.0 Julia comes with built-in mathematical functions like the square root:\njulia\u0026gt; sqrt(9) 3.0 The spaces between the numbers and operators are not mandatory, but adding a single space tends to make it easier to read. Any of the following examples are valid:\njulia\u0026gt; 2+2 4 julia\u0026gt; 2 + 2 4 julia\u0026gt; sqrt( 4 ) 2.0 Numbers can be written in scientific notation with e. For example, you can write \\( 2.998 \\times 10^8 \\) both as:\njulia\u0026gt; 2.998 * 10^8 2.998e8 julia\u0026gt; 2.998e8 2.998e8 Julia comes with some built-in mathematical constants like Ï€. You can refer to it with pi:\njulia\u0026gt; pi^2 / 6 1.6449340668482264 You can also insert the Ï€ symbol in the REPL by typing \\pi and pressing the TAB key.\njulia\u0026gt; \\pi After pressing TAB and entering the expression:\njulia\u0026gt; Ï€ Ï€ = 3.1415926535897... Exercises Exercise 1 If you took all the bacteria in the ocean and lined them up end to end, how far would they reach?\nFirst, take a guess. Then, expand the section below and use the data to calculate an approximation.\nUseful Data â†• There is about 1.335Ã—1021 liters of water in the ocean A single liter of seawater has about 100 million bacteria The average bacteria is about 3 Âµm long (1 Âµm = 10-6 m) 1 lightyear is about 9.461Ã—1015 m For reference, the distance to the nearest galaxy (Andromeda) is about 2.537 million light years Exercise 2 If you packed every human on earth into a mound, how high would it stand?\nAgain, take a guess. Then, use the data below to calculate an approximation.\nUseful Data â†• The average human takes up a volume of about 0.065 m3 You can assume that 5% of the moundâ€™s volume is empty space You can also assume that the mound is a 45Â° cone The formula for the volume V of a 45Â° cone in terms of its height h is: \\[V = \\frac13 \\pi h^3\\] "},{"id":3,"href":"/getting-started/setup/","title":"Setup","parent":"Getting Started","content":"You can download Julia at https://julialang.org/downloads/. For specific instructions, see https://julialang.org/downloads/platform/.\nOnce installed, open a command line, type julia, and press enter. You should see something similar to the following output:\n$ julia _ _ _ _(_)_ | Documentation: https://docs.julialang.org (_) | (_) (_) | _ _ _| |_ __ _ | Type \u0026quot;?\u0026quot; for help, \u0026quot;]?\u0026quot; for Pkg help. | | | | | | |/ _` | | | | |_| | | | (_| | | Version 1.7.3 (2022-05-06) _/ |\\__\u0026apos;_|_|_|\\__\u0026apos;_| | Official https://julialang.org/ release |__/ | julia\u0026gt; To exit the program, press CTRL-d or type exit() and press enter.\n"},{"id":4,"href":"/scripting/text-editor/","title":"Text Editor","parent":"Scripting","content":"The REPL is great for typing code interactively, but not for saving code for future use. In order to save your code, you need to save it to a file. Any text editor will do, but some have features specifically for programming.\nFor example, many text editors have syntax highlighting. This means that they highlight different characters based on their meaning in the code.\nfunction f(x) return x^2 - sqrt(x) + cos(x / 5) end function f(x) return x^2 - sqrt(x) + cos(x / 5) end VS Code You can download VSCode here.\nAlthough VSCode is open source, the downloadable product contains telemetry/tracking. If you wish to opt out of this tracking, take a look at VSCodium. "},{"id":5,"href":"/getting-started/julia-intro/","title":"Julia Intro","parent":"Getting Started","content":" Programming Computers only understand ones and zeros. When a computer runs a program, it\u0026rsquo;s really reading something like this:\n01111111 01000101 01001100 01000110 00000010 00000001 00000001 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 Computers understand this just fine. Humans, on the other hand, have a difficult time writing and understanding instructions like these.\nIn order to make writing this easier, programming languages were invented. Humans write code in a programming language, and that code is translated into ones and zeros that the computer can run.\nSome programming languages involve giving bare-bones commands to the computer. Text written in these languages usually gets translated to a similar amount of ones and zeros. These are generally called low level langauges. The opposite of low level languages are high level langauges, where one simple command can translate to tons of ones and zeros.\nLow level languages are useful for pushing a computer to its limits, but they are generally harder to write. High level languages allow humans to quickly write and understand code without having to worry about the low level details. Using a high level language is like ordering food at a restaurant whereas a low level language is like cooking a dish from scratch.\nConsider a program that simply prints \u0026ldquo;Hello World\u0026rdquo; to the screen. Here is what that program would look like in various languages, roughly from low to high level.\nx86-64 Assembly (Linux) global _start section .text _start: mov rax, 1 mov rdi, 1 mov rsi, msg mov rdx, msglen syscall mov rax, 60 mov rdi, 0 syscall section .rodata msg: db \u0026#34;Hello, World!\u0026#34;, 10 msglen: equ $ - msg C #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;Hello, World!\\n\u0026#34;); return 0; } Java class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello, World!\u0026#34;); } } Julia println(\u0026#34;Hello, World!\u0026#34;) Python print(\u0026#34;Hello, World!\u0026#34;) Lisp (print \u0026#34;Hello, World!\u0026#34;) The Julia Language Julia is a relatively new programming language. Version 1.0 was released in August of 2018. It was designed with computational scientists in mind, but it is a general purpose language too.\nLike most other languages, Julia code is executed from the top down. For example, the following code prints \u0026ldquo;ready\u0026rdquo;, \u0026ldquo;set\u0026rdquo;, and \u0026ldquo;go\u0026rdquo; in that order.\nprintln(\u0026#34;ready\u0026#34;) println(\u0026#34;set\u0026#34;) println(\u0026#34;go\u0026#34;) "},{"id":6,"href":"/scripting/scripts/","title":"Scripts","parent":"Scripting","content":" Script Structure A Julia script is simply a file with Julia code. When you run a script, the result is similar to running each line of code in the REPL from top to bottom. For example, consider the following script:\nx = 2 + 2 y = 5x - 3 x * y Running this script would be similar to the following REPL commands:\njulia\u0026gt; x = 2 + 2 4 julia\u0026gt; y = 5x - 3 17 julia\u0026gt; x * y 68 However, the results of each expression are not shown automatically like in the REPL.\nFirst Script Often the first program people learn to write is the \u0026ldquo;Hello, World!\u0026rdquo; program. All it does is print Hello, World! to the screen. Open a file named hello.jl and write the following line of code:\nprintln(\u0026#34;Hello, World!\u0026#34;) There are a few ways to actually run this script now. First, open a terminal in the same directory as hello.jl. Then, type julia hello.jl and press enter. You should see the following output:\n$ julia hello.jl Hello, World! You can execute a script from inside the REPL as well. Open the REPL with the julia command and type include(\u0026quot;hello.jl\u0026quot;):\njulia\u0026gt; include(\u0026quot;hello.jl\u0026quot;) Hello, World! The include function executes a Julia file\u0026rsquo;s contents as if they were typed in the REPL.\n"},{"id":7,"href":"/calculations/variables/","title":"Variables","parent":"Calculations","content":" Assigning Variables Often times you want to store the results of calculations for later use. Instead of writing down numbers and typing them out again, you can assign a variable with = (the assignment operator).\njulia\u0026gt; x = sqrt(2) 1.4142135623730951 Now, you can use x in place of 1.4142135623730951 in your future calculations.\njulia\u0026gt; x + 1 2.414213562373095 You can also reassign x to another value if you change your mind:\njulia\u0026gt; x = 1.5 1.5 julia\u0026gt; x + 2 3.5 It is important to note that = in Julia is not like equality in math. It is called an assignment operator because it assigns the variable on the left side to the value on the right side. Variable names don\u0026rsquo;t have to be a single character. They can be multiple characters long and contain letters, underscores (i.e. _), numbers, and even emoji. They cannot start with a number, though.\njulia\u0026gt; days_in_week = 7 7 julia\u0026gt; my_variable = 3 * days_in_week 21 julia\u0026gt; ðŸ˜‚ = 5/7 0.7142857142857143 You can\u0026rsquo;t start a variable name with a number because Julia interprets a number before a variable as multiplication. For example:\njulia\u0026gt; x = 3 3 julia\u0026gt; 5x 15 If you want to see the value of a variable, you can just evaluate it by itself:\njulia\u0026gt; x = 12 * 21 252 julia\u0026gt; x 252 Changing Variables It\u0026rsquo;s often useful to change the value stored in a variable. For example, say you had a quantity stored in meters inside a variable called distance and you want to store it in centimeters instead.\njulia\u0026gt; distance = 1.5 1.5 The value in centimeters is distance * 100, so this value is stored back into distance.\njulia\u0026gt; distance = distance * 100 150.0 Remember, the left hand side of an assignment has the variables that are being stored. The right hand side is the value. When the code gets executed, the distance on the right side is substituted for its value:\njulia\u0026gt; distance = 1.5 * 100 150.0 Exercises Exercise 1 Using NASA\u0026rsquo;s planetary fact sheet, make variables for the mass of each planet in the solar system, the moon, and Pluto. Also make a variable for the sun\u0026rsquo;s mass using NASA\u0026rsquo;s sun fact sheet.\nThen, answer the following questions:\nWhat percent of the solar system\u0026rsquo;s total mass does the sun take up? What about Earth? Jupiter? In kg, how much more mass does Jupiter have than Saturn? How many Earths worth of mass is this? How many more times massive is the moon than Pluto? Exercise 2 Determine the mass in kg of a few everyday objects (like a car or banana) and make a variable for each one.\nFor each of these object, determine how many of them have the same mass as\nThe solar system Jupiter Earth Pluto "},{"id":8,"href":"/calculations/functions/","title":"Functions","parent":"Calculations","content":" Assignment-Style Functions In the same sense that variables can help you use the same value multiple times, functions can help you use the same expression multiple times. Say you\u0026rsquo;re working with the following quadratic polynomial:\n\\[f(x) = 3x^2 - 5x \u0026#43; 6\\] The = operator can assign an expression to a function. In this case, we want f(x) to represent the expression 3x^2 - 5x + 6:\njulia\u0026gt; f(x) = 3x^2 - 5x + 6 f (generic function with 1 method) The x inside this function is not accessible from outside. Variables that are only accessible from the inside are called local variables. Note that the name x is not special here. We could also do:\njulia\u0026gt; f(num) = 3num^2 - 5num + 6 f (generic function with 1 method) Now, we can evaluate the polynomial at x=1 without typing the expression:\njulia\u0026gt; f(1) 4 Functions can be named like variables:\njulia\u0026gt; triple(x) = 3x triple (generic function with 1 method) julia\u0026gt; triple(5) 15 julia\u0026gt; raise_to_itself(x) = x ^ x raise_to_itself (generic function with 1 method) julia\u0026gt; raise_to_itself(3) 27 julia\u0026gt; add4(x) = x + 4 add4 (generic function with 1 method) julia\u0026gt; add4(2) 6 Multi-line Functions If the code you want to wrap in a function requires multiple expressions, it\u0026rsquo;s best to put it in a function block. This is what f would look like if we defined it this way:\njulia\u0026gt; function f(x) 3x^2 - 5x + 6 end The first line function f(x) specifies that we are defining a function named f that takes an argument called x. When you type this in the REPL, Julia recognizes that you are in the middle of typing a function and creates a new line when you press enter.\nThe next line has the expression that we wish to compute just as in the one line version. Before typing this part, press tab to indent a level. The indentation isn\u0026rsquo;t required, but it makes it a lot easier to tell which code belongs to a function.\nThe final line just has end, telling Julia that you are done defining the function.\nThe value of the last expression in a function is the output. We typically call this the function\u0026rsquo;s return value. If you provide f some input y like f(y), it is replaced with the return value (in this case, 3y^2 - 5y + 6).\nYou can explicitly specify an output by prefixing it with return.\njulia\u0026gt; function f(x) return 3x^2 - 5x + 6 end Since the code in function is executed from the top down, nothing after the return statement is executed. For example:\njulia\u0026gt; function g(x) return 2x return 9000 end g (generic function with 1 method) julia\u0026gt; g(5) 10 Example: Cost of a Flight Say you were making a function to calculate the total cost of an airplane ride given the distance d it travels. You might consider several sources of cost:\nFuel costs $200 for taxi/takeof/landing and $100 per km the plane travels Personnel costs $40 per km Servicing the plane before takeoff and after landing costs $1000 Your function might look like:\njulia\u0026gt; cost(d) = 200 + 100d + 40d + 1000 What if later you find out that fuel now costs $110 per km? In this example, it\u0026rsquo;s pretty simple to find the 100d and change it to 110d, but as your code gets more complex this becomes unfeasible. One way to address this is to make variabes inside the function:\njulia\u0026gt; function cost(d) fuel = 200 + 100d personnel = 40d service = 1000 fuel + personnel + service end The last expression (fuel + personnel + service) is returned. It\u0026rsquo;s good practice to explicitly state what statement you\u0026rsquo;re returning if a function has multiple lines of code, but you don\u0026rsquo;t need to. If you did, the function would look like:\njulia\u0026gt; function cost(d) fuel = 200 + 100d personnel = 40d service = 1000 return fuel + personnel + service end Multiple Parameters The x in a function like f(x) = x^2 is called the function\u0026rsquo;s parameter. In mathematics, functions can have multiple parameters. For example,\n\\[f(x, y) = x \u0026#43; y\\] \\(x\\) and \\(y\\) are the function\u0026rsquo;s parameters. Just like a one-parameter function, you can evaluate the function by substituting the variables:\n\\[f(1, 2) = 1 \u0026#43; 2\\] 1 and 2 are the arguments in this case.\nParameters and arguments are technically not the same. Parameters are the variables that receive the input values and arguments are the expressions that are assigned to the parameters. Functions in Julia can have multiple parameters as well. For example, you could create an add function that adds two numbers:\njulia\u0026gt; add(x, y) = x + y add (generic function with 1 method) julia\u0026gt; add(1, 2) 3 That is not very impressive though. A function cone_volume that computes the volume of a cone might be more useful:\njulia\u0026gt; function cone_volume(radius, height) base_area = pi * radius^2 return 1/3 * height * base_area end cone_volume (generic function with 1 method) julia\u0026gt; cone_volume(1, 3) 3.141592653589793 Functions can also have no arguments. Mathematically, a function without arguments would always have the same output. Functions in Julia can depend on the external state of the world, so they are not pure mathematical functions. For example, the time() function returns the number of seconds since January 1, 1970.\njulia\u0026gt; time() 1.656337427111429e9 We can use this value to find the current year:\njulia\u0026gt; 1970 + time() / (365.25 * 24 * 60^2) 2022.486167415259 We can also subtract two times to measure duration:\njulia\u0026gt; t1 = time() 1.656337287725287e9 julia\u0026gt; t2 = time() 1.656337292604609e9 julia\u0026gt; t2 - t1 4.879322052001953 Returning Multiple Values Functions can only return a single value. If you want to return multiple values, you\u0026rsquo;ll have to wrap them inside a single value. One way to do this is with a tuple.\nA tuple is an ordered list of fixed size. The most common tuple you\u0026rsquo;ve probably seen are coordinates on a plane. For example, the point with \\(x=3\\) and \\(y=4\\) has coordinates \\((3, 4)\\), a tuple of two numbers. In Julia, you write tuples in the same way: (3, 4). A tuple of three numbers might look like (1, 2, 3).\njulia\u0026gt; (1, 2, 3) (1, 2, 3) julia\u0026gt; x = 5 5 julia\u0026gt; y = 10 10 julia\u0026gt; point = (x, y) (5, 10) The parentheses around a tuple are actually optional in some cases, but I recommend that you always use them so it is clearly a tuple.\njulia\u0026gt; x = 1, 2 (1, 2) Example: Hours, Minutes, Seconds Consider a function that converts total seconds to hours, minutes and seconds. For example, 90 seconds should be 0 hours, 1 minute, and 30 seconds.\nSince this function needs to return multiple values, you can return them as a tuple (hours, minutes, seconds).\njulia\u0026gt; function seconds_to_HMS(secs) hours = secs Ã· 3600 minutes = (secs - 3600 * hours) Ã· 60 seconds = secs - 3600 * hours - 60 * minutes return (hours, minutes, seconds) end seconds_to_HMS (generic function with 1 method) Explanation â†• secs / 3600 gives the total number of hours (including a fractional part in general). In order to get a whole number of hours, we will use div instead.\ndiv(x, y) returns the result of x / y after rounding towards zero. For example, div(5, 2) is 2. There is an operator for this function Ã· which you can type in the REPL by typing \\div and pressing tab. Then, div(x, y) is the same as x Ã· y.\njulia\u003e 7 Ã· 4 1 julia\u003e div(7, 4) 1 julia\u003e 8 Ã· 4 2 hours is then secs Ã· 3600.\nminutes is then (secs - 3600 * hours) Ã· 60 since 3600 * hours seconds were already accounted for.\nseconds is the total seconds minus those account for in hours and minutes: secs - 3600 * hours - 60 * minutes.\nThen, we return a tuple containing these 3 values: (hours, minutes, seconds).\nTesting this function out gives the expected results:\njulia\u0026gt; seconds_to_HMS(35) (0, 0, 35) julia\u0026gt; seconds_to_HMS(90) (0, 1, 30) julia\u0026gt; seconds_to_HMS(3723) (1, 2, 3) Methods Up until now, we\u0026rsquo;ve ignored the message generic function with 1 method that you get after defining a function. To understand it, you\u0026rsquo;ll need to know the difference between a function and a method.\nFunction vs Method You can think of a method as a function and a specific pattern of parameters. It\u0026rsquo;s easier to understand with an example, though. Consider the add function from the previous section.\njulia\u0026gt; add(x, y) = x + y add (generic function with 1 method) The above code defines a method for the add function with parameters (x, y). Functions in Julia can have multiple methods. For example, you could define a method of add with 3 parameters:\njulia\u0026gt; add(x, y, z) = x + y + z add (generic function with 2 methods) Notice that the add function now has 2 methods. One method takes (x, y) and the other takes (x, y, z).\nYou can redefine methods, but you cannot delete them. If you wish to clear all the methods from a function, you must restart the REPL. Multiple Dispatch When you call a function, Julia has to decide which method to use. It does this by finding a method with matching parameters. For example, take the add function and the 2 methods we defined previously:\nadd(x, y) = x + y add(x, y, z) = x + y + z Say you call the function with add(5, 10). That fits the pattern specified by the first method add(x, y) since there are 2 arguments. Therefore, the code 5 + 10 is executed. If you called the function with add(1, 2, 3), it would match the second method add(x, y, z).\nYou can call other methods from the same function:\nadd(a, b, c, d) = add(a, b) + add(c, d) Be careful that your methods don\u0026rsquo;t call each other in an infinite loop.\njulia\u0026gt; f(x) = f(x, 0) f (generic function with 1 method) julia\u0026gt; f(x, y) = f(x + y) f (generic function with 2 methods) Calling f(1) calls f(1, 0) which calls f(1) which calls f(1, 0) and so on forever. In reality, your computer will give up after a short while:\njulia\u0026gt; f(1) ERROR: StackOverflowError: Stacktrace: [1] f(x::Int64) @ Main ./REPL[1]:1 [2] f(x::Int64, y::Int64) @ Main ./REPL[2]:1 --- the last 2 lines are repeated 39990 more times --- [79983] f(x::Int64) @ Main ./REPL[1]:1 There are more ways to specify argument patterns other than the number of arguments. You will learn more about these in a later section.\nExercises Exercise 1 Make a function feet_to_cm that converts a quantity in feet to centimeters. It should have two methods:\nfeet_to_cm(feet) feet_to_cm(feet, inches) For example:\n6 feet = 182.88 cm 5 feet 11 inches = 180.34 cm julia\u0026gt; feet_to_cm(6) 182.88 julia\u0026gt; feet_to_cm(5, 11) 180.34 Exercise 2 Write a function quadratic_roots(a, b, c) that returns the roots of a quadratic polynomial with coefficients a, b, and c:\n\\[ax^2 \u0026#43; bx \u0026#43; c\\] For example,\njulia\u0026gt; quadratic_roots(2, -4, -16) (-2.0, 4.0) "},{"id":9,"href":"/scripting/jupyter/","title":"Jupyter Notebooks","parent":"Scripting","content":""},{"id":10,"href":"/getting-started/repl-intro/","title":"REPL Intro","parent":"Getting Started","content":"When you type julia in the command line, you should get an output like this:\n$ julia _ _ _ _(_)_ | Documentation: https://docs.julialang.org (_) | (_) (_) | _ _ _| |_ __ _ | Type \u0026quot;?\u0026quot; for help, \u0026quot;]?\u0026quot; for Pkg help. | | | | | | |/ _` | | | | |_| | | | (_| | | Version 1.7.3 (2022-05-06) _/ |\\__\u0026apos;_|_|_|\\__\u0026apos;_| | Official https://julialang.org/ release |__/ | julia\u0026gt; This is called the Julia REPL (short for read-eval-print-loop). The REPL allows you to write code interactively instead of saving it in a file. In its most basic form, the REPL acts like a calculator. Type an expression like 2 + 2 and press enter. You should see the result on the next line:\njulia\u0026gt; 2 + 2 4 julia\u0026gt; 7 * 8 56 To exit the REPL, press CTRL-d or type exit() and press enter.\n"},{"id":11,"href":"/calculations/errors/","title":"Errors","parent":"Calculations","content":"When Julia cannot understand or run a command, you will get an error. Being a good programmer is more about knowing how to interpret errors than never getting them. Let\u0026rsquo;s go through a couple basic errors you might get when typing in the REPL.\nSyntax Errors Extra Space Syntax errors occur when Julia can\u0026rsquo;t understand your code. You might get one if you accidentally type a space where you shouldn\u0026rsquo;t:\njulia\u0026gt; 12 3 + 1 ERROR: syntax: extra token \u0026quot;3\u0026quot; after end of expression Stacktrace: [1] top-level scope @ none:1 Errors can sometimes look overwhelming, but most of the time all the information you need is on the first couple lines. In this case, all we need is the first line of the error message:\nERROR: syntax: extra token \u0026quot;3\u0026quot; after end of expression ERROR: syntax means that Julia couldn\u0026rsquo;t understand the code you wrote. The text that follows tells you exactly what Julia couldn\u0026rsquo;t understand. In this case, Julia read 12 as a full number and was expecting an operator like + or * to follow it. Since Julia got 3 and not an operator, it gave up and threw an error.\nThis line alone gives you enough information to change 12 3 to 123. Right now, you don\u0026rsquo;t need to worry about the Stacktrace that follows the first line. Later on, you\u0026rsquo;ll learn how to use it to decipher more complex errors.\nMismatched Brackets Another syntax error you get is caused by mismatched brackets. For example, if you add one two many closing parentheses:\njulia\u0026gt; (1 + 2)) ERROR: syntax: extra token \u0026quot;)\u0026quot; after end of expression Stacktrace: [1] top-level scope @ none:1 Assigning to a Value The statement 1 = 1 looks alright from a mathematical perspective. However, it doesn\u0026rsquo;t work in Julia.\njulia\u0026gt; 1 = 1 ERROR: syntax: invalid assignment location \u0026quot;1\u0026quot; around REPL[1]:1 Stacktrace: [1] top-level scope @ REPL[1]:1 Remember that = is the assignment operator in Julia. 1 = 1 translates to \u0026ldquo;assign 1 to the variable 1.\u0026rdquo; This doesn\u0026rsquo;t work since 1 isn\u0026rsquo;t a variable.\nUndefined Variable Errors Another common error is trying to access a variable or function that doesn\u0026rsquo;t exist. This can happen if you make a typo:\njulia\u0026gt; sqrt(9) 3.0 julia\u0026gt; ssqrt(4) ERROR: UndefVarError: ssqrt not defined Stacktrace: [1] top-level scope @ REPL[3]:1 Again, the first line of the error tells you that ssqrt not defined.\nExercises Exercise 1 The following code has a couple mistakes. Find and remove them so that it runs without error.\nsqrt(5 * sqrt(3 - 6/5 + 152.926))) / (5 * sqet(6.2)) Exercise 2 Consider a body with gravitational parameter \\(\\mu\\) The force of gravity on a body with mass \\(m\\) at a position \\((x,y,z)\\) relative to the attracting body is:\n\\[ \\vec{F} = \\left(-F \\frac{x}{r}, -F \\frac{y}{r}, -F \\frac{z}{r}\\right)\\] Where \\(F\\) is the magnitude of the force (found with Newton\u0026rsquo;s law of gravitation):\n\\[ F = \\frac{\\mu m}{r^2}\\] And where \\(r\\) is the distance between the bodies:\n\\[ r = \\sqrt{x^2 \u0026#43; y^2 \u0026#43; z^2}\\] The following function is meant to return a tuple that represents \\(\\vec{F}\\), but there are some errors. Fix the errors so that the function runs.\nfunction gravity_force(Î¼, m, x, y, z) r = sqrt (x^2 + y^2 + z^2) F = Î¼m/R^2 output (-F * x/r, -F * y/r, --F * z/r) end You can test your function with:\njulia\u0026gt; gravity_force(1e9, 1e5, -3e5, 5e5, 2e4) (151.05563385525724, -251.75938975876204, -10.070375590350482) julia\u0026gt; gravity_force(1e10, 1e2, 1e5, 2e4, -8e4) (-45.92361606014639, -9.184723212029278, 36.73889284811711) "},{"id":12,"href":"/scripting/scripting-workflow/","title":"Scripting Workflow","parent":"Scripting","content":"The following steps are often useful for working on code:\nWrite some code Test the code interactively Repeat Script + REPL For example, say you\u0026rsquo;re working on some code in a file named work.jl\n# work.jl function foo(a, b, c) # lots of code end function bar(x, y) # lots of code end Now, you can start up a REPL and include the work.jl file.\njulia\u0026gt; include(\"work.jl\") You can now test the foo and bar functions in the REPL.\njulia\u0026gt; foo(1, 2, 3) julia\u0026gt; bar(64, 128) Jupyter Notebook Since a text editor is integrated into a jupyter notebook, you can skip the include step and write your code directly into a cell. Note that you cannot include jupyter notebooks from other files. If you want to use your code elsewhere, you\u0026rsquo;ll have to put it in a Julia file.\n"},{"id":13,"href":"/calculations/patterns/","title":"Patterns","parent":"Calculations","content":" Assigning Variables Consider the following assignment:\njulia\u0026gt; a = 4 4 The = operator can actually do bit more than assigning a value to a variable. You can actually thing of the left side as a pattern that is matching the right side.\nA variable name is a pattern that matches anything, including tuples for example.\njulia\u0026gt; b = (1, 2) (1, 2) julia\u0026gt; b (1, 2) What if we want to assign values in a tuple to separate variables? That is where pattern matching comes in handy:\njulia\u0026gt; x, y = b (1, 2) julia\u0026gt; x 1 julia\u0026gt; y 2 x, y is a pattern that represents a list of 2 numbers. Since b is a tuple of 2 numbers (1, 2), it matches that pattern. The corresponding values are assigned to x and y.\nThe left side of an assignment is the pattern and the right side is the value. Variables on the ride side are expanded to their actual values, and variables on the left side are assigned to their corresponding value on the right.\nYou can surround the pattern with parentheses if you\u0026rsquo;d like:\njulia\u0026gt; (x, y) = b (1, 2) Although it looks like a tuple, (x, y) is not a tuple. The left side of an assignment is always a pattern.\nHere is another example:\njulia\u0026gt; (hours, minutes, seconds) = (5, 3, 32) (5, 3, 32) julia\u0026gt; hours 5 julia\u0026gt; minutes 3 julia\u0026gt; seconds 32 The pattern x, y actually matches any list with at least 2 elements. For example:\njulia\u0026gt; x, y = (1, 2, 3) (1, 2, 3) julia\u0026gt; x 1 julia\u0026gt; y 2 If the pattern in an assignment doesn\u0026rsquo;t match, you get an error:\njulia\u0026gt; x, y, z = (1, 2) ERROR: BoundsError: attempt to access Tuple{Int64, Int64} at index [3] Stacktrace: [1] indexed_iterate(t::Tuple{Int64, Int64}, i::Int64, state::Int64) @ Base ./tuple.jl:89 [2] top-level scope @ REPL[7]:1 You can even match lists inside lists. For example:\njulia\u0026gt; a = (1, (2, 3)) (1, (2, 3)) julia\u0026gt; x, (y, z) = a (1, (2, 3)) julia\u0026gt; (x, y, z) (1, 2, 3) Assigning Functions Assigning a function is like a delayed pattern match. Consider the function f:\njulia\u0026gt; f(x) = x^2 f (generic function with 1 method) f(3) matches the pattern f(x) and therefore is replaced with 3^2. This is just like how after the assignment y = 3, y is replaced with 3.\nThe same works with multiple parameters:\njulia\u0026gt; g(a, b) = a - b g (generic function with 1 method) julia\u0026gt; g(5, 3) 2 Each parameter is a pattern just like in the left side of an assignment. For example, you could do:\njulia\u0026gt; h(a, (x, y)) = a + x + y h (generic function with 1 method) julia\u0026gt; h(1, (2, 3)) 6 julia\u0026gt; h(1, (2, 3, 10000)) 6 For example, calling h(1, (2, 3)) makes the following assignments inside h:\na = 1 (x, y) = (2, 3) "},{"id":14,"href":"/scripting/scripting-tools/","title":"Scripting Tools","parent":"Scripting","content":" Comments You can prevent part of your code from being executed by putting it after a #. This is called a \u0026ldquo;comment\u0026rdquo;.\n# this line is ignored x = 1 # this text is ignored You can comment multiple lines by starting them with #= and ending them with =#.\nx = 1 # this line will run #= these lines will not run: y = 2 z = 3 =# Comments are also useful for annotating. When your code gets larger and more complicated, it becomes difficult to remember what it does and how it works. Adding comments helps you remember what your code does.\nDisplaying Output Terminal Output When you run Julia in the terminal, results can be showed to the standard output stream. You can think of this stream as someone typing on a keyboard. You can instruct this figurative keyboard to type anything you want with Julia.\nIn the following sections, â€¸ will represent the current position of the caret. For example, the result of typing \u0026ldquo;hello\u0026rdquo;, the enter key, and \u0026ldquo;world\u0026rdquo; would look like:\nhello worldâ€¸ Printing Print Line The println (short for print line) function takes any amount of arguments, prints them one by one, then advances to the next output line (like pressing enter on the keyboard).\nprintln(\u0026#34;hello\u0026#34;) x = 19 y = 5 println(\u0026#34;The value of x is \u0026#34;, x) println(\u0026#34;x + y = \u0026#34;, x + y) After the first println function runs, the terminal output will look like:\nhello â€¸ Notice the cursor is on the next line. After the next two print statements the total output will be:\nhello123 The value of x is 19 x + y = 24 â€¸ Print The print function does the same thing as println without advancing to the next output line. A simple example:\nprint(\u0026#34;hello \u0026#34;) print(\u0026#34;world\u0026#34;) After the first print runs, the output will look like:\nhello â€¸ After the next print, the output will be\nhello worldâ€¸ Notice that the cursor is still on the same line. If you try to print something else, it will all be on the same line:\nprint(\u0026#34;hello \u0026#34;) print(\u0026#34;world\u0026#34;) println(\u0026#34;what\u0026#39;s up\u0026#34;) hello worldwhat\u0026#39;s up â€¸ There are a couple ways to fix this issue. Firstly, you could call println(). Since there are no arguments, it simply advances to the next line:\nprint(\u0026#34;hello \u0026#34;) print(\u0026#34;world\u0026#34;) println() # advances to next line of output println(\u0026#34;what\u0026#39;s up\u0026#34;) hello world what\u0026#39;s up â€¸ Many programming languages have special characters that mimic things like enter and tab on the keyboard. To mimic the enter key, type the two characters \\n inside a string. The n stands for new line.\nprint(\u0026#34;hello \u0026#34;) print(\u0026#34;world\\n\u0026#34;) # add \\n to mimic the enter key println(\u0026#34;what\u0026#39;s up\u0026#34;) hello world what\u0026#39;s up â€¸ "},{"id":15,"href":"/scripting/repl-tools/","title":"REPL Tools","parent":"Scripting","content":" Getting Help If you\u0026rsquo;re ever unsure what an operator (like +), function (like abs), or variable (like pi) does, you can use the REPL\u0026rsquo;s built-in help system. Start on a blank prompt and type a single ? character:\njulia\u0026gt; ? This will automatically bring up the help?\u0026gt; prompt:\nhelp?\u0026gt; Now type the name of the item you\u0026rsquo;re curious about and press enter. We\u0026rsquo;ll start with the + operator:\nhelp?\u0026gt; + search: + +(x, y...) Addition operator. x+y+z+... calls this function with all arguments, i.e. +(x, y, z, ...). Examples â‰¡â‰¡â‰¡â‰¡â‰¡â‰¡â‰¡â‰¡â‰¡â‰¡ julia\u0026gt; 1 + 20 + 4 25 julia\u0026gt; +(1, 20, 4) 25 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ dt::Date + t::Time -\u0026gt; DateTime The addition of a Date with a Time produces a DateTime. The hour, minute, second, and millisecond parts of the Time are used along with the year, month, and day of the Date to create the new DateTime. Non-zero microseconds or nanoseconds in the Time type will result in an InexactError being thrown. The examples section is very useful to learn the usage at a glance. The second example actually shows a feature of + that you probably haven\u0026rsquo;t used in this course before: it also acts like a function. a + b is the same as +(a, b).\nThe second help section that involves Date and Time is less useful to you right now. All that\u0026rsquo;s important to know right now is that the section is there because + has a special definition for dates and times.\nNow, let\u0026rsquo;s look at the help output for the abs function.\nhelp?\u0026gt; abs search: abs abs2 abspath abstract AbstractSet \u0026apos;abstract type\u0026apos; AbstractChar abs(x) The absolute value of x. When abs is applied to signed integers, overflow may occur, resulting in the return of a negative value. This overflow occurs only when abs is applied to the minimum representable value of a signed integer. That is, when x == typemin(typeof(x)), abs(x) == x \u0026lt; 0, not -x as might be expected. See also: abs2, unsigned, sign. Examples â‰¡â‰¡â‰¡â‰¡â‰¡â‰¡â‰¡â‰¡â‰¡â‰¡ julia\u0026gt; abs(-3) 3 julia\u0026gt; abs(1 + im) 1.4142135623730951 julia\u0026gt; abs(typemin(Int64)) -9223372036854775808 If you weren\u0026rsquo;t sure before, the first line of the help output tells you that abs(x) is the absolute value of x. There is an additional paragraph that explains some subtleties but you don\u0026rsquo;t need to worry about those right now.\nFinally, let\u0026rsquo;s look at the help output for the variable pi.\nhelp?\u0026gt; pi search: pi Pipe pipeline PipeBuffer sinpi cospi cispi getpid rem2pi mod2pi print Ï€ pi The constant pi. Unicode Ï€ can be typed by writing \\pi then pressing tab in the Julia REPL, and in many editors. See also: sinpi, sincospi, deg2rad. Examples â‰¡â‰¡â‰¡â‰¡â‰¡â‰¡â‰¡â‰¡â‰¡â‰¡ julia\u0026gt; pi Ï€ = 3.1415926535897... julia\u0026gt; 1/2pi 0.15915494309189535 Again, there is a brief description at the start and some examples at the bottom.\n"},{"id":16,"href":"/getting-started/","title":"Getting Started","parent":"Learning Julia","content":""},{"id":17,"href":"/","title":"Learning Julia","parent":"","content":""},{"id":18,"href":"/tags/","title":"Tags","parent":"Learning Julia","content":""}]